name: ask llm to comment when user adds chatcompletion as a tag to issue or pr

on:
  issues:
    types:
      - labeled
  pull_request:
    types:
      - labeled

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v2

      - name: Check for 'chatcompletion' label
        run: |
          if [[ ${{ github.event.label.name }} == "chatcompletion" ]]; then
            echo "Label 'chatcompletion' was added!"
          else
            echo "Label 'chatcompletion' was not added. Workflow will be skipped."
            exit 0
          fi
          
      - name: Fetch Issue Comments
        id: comments
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          echo "$GH_PAT" | gh auth login --with-token
          COMMENTS=$(gh issue view "$ISSUE_NUMBER" --json comments -q '.comments')
          echo "::set-output name=comments::$COMMENTS"

      - name: Process Issue
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENTS: ${{ steps.comments.outputs.comments }}
        run: |
          # Escape special JSON characters in shell variables
          ISSUE_TITLE_JSON=$(jq -aRs . <<< "$ISSUE_TITLE")
          ISSUE_BODY_JSON=$(jq -aRs . <<< "$ISSUE_BODY")
          COMMENTS_JSON=$(jq -aRs . <<< "$COMMENTS")
          # Extract comments as an array
          COMMENTS_ARRAY=$(echo $COMMENTS_JSON | jq -c '.[]')

          # Initialize an empty array for formatted messages
          FORMATTED_MESSAGES=()

          # Variable to keep track of the current role
          CURRENT_ROLE="user"

          # Iterate through each comment
          for COMMENT in $COMMENTS_ARRAY
          do
              # Append the comment with the current role to the formatted messages
              FORMATTED_MESSAGES+=("{\"role\": \"$CURRENT_ROLE\", \"content\": $COMMENT}")

              # Toggle the current role for the next iteration
              if [ "$CURRENT_ROLE" = "user" ]; then
                  CURRENT_ROLE="assistant"
              else
                  CURRENT_ROLE="user"
              fi
          done

          # Join the formatted messages into a JSON array
          FORMATTED_MESSAGES_JSON=$(printf '%s\n' "${FORMATTED_MESSAGES[@]}" | jq -s '.')

          # Formulate the prompt with comments
          PROMPT=$(jq -n \
              --arg model "gpt-4-1106-preview" \
              --arg taskContent "Task: I am apimesh, a next-generation LLM interface specialized in providing concise, efficient solutions. My focus is on simplifying complex problems and offering easy-to-understand solutions, emphasizing streamlined tools like actionindexer. Key responsibilities include understanding projects by reading the readme and using the textraw-server to retrieve relevant information (http://2.201.132.120:8000/{user}/{repo}/{branch}/{filepath}). The textraw-server is completely described by the provided script, which includes steps for stopping conflicting Docker containers, creating a server script for a FastAPI application, managing dependencies, setting up Docker, and deploying the FastAPI server. My approach is to offer clear, actionable advice based on the user's query, ensuring the solutions are straightforward and tailored to specific needs. when the user wants to create a new microserver 'okay tell me how you would use that api to create a new microserver that specializes in doing nothing else but using langchain to run a particular llm chain' it should just answer with 'run `curl http://...neuralmesh/textraw-server/main/gitraw-server.sh` and use the actual content of the script as reference and only change the server code to do exactly one specificc task. the information that is received from the textraw-server will be the sccript that sets up the end2end server api, including the entire python script."\
              --arg issueTitle "$ISSUE_TITLE_JSON" \
              --arg issueNumber "$ISSUE_NUMBER" \
              --arg issueBody "$ISSUE_BODY_JSON" \
              --arg comments "$COMMENTS_JSON" \
              '{model: $model, messages: [{role: "system", content: $taskContent}, {role: "user", content: ($issueTitle +
" (Issue Number: " + $issueNumber + ", Body: " + $issueBody + ")")}, $formattedMessages]}' )
          echo "Prompt: $PROMPT"

          # Send a request to the OpenAI API
          RESPONSE=$(curl -s "https://api.openai.com/v1/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "$PROMPT"
          )
          echo "Response: $RESPONSE"

          # Extract the answer
          ANSWER=$(echo "$RESPONSE" | jq -r .choices[0].message.content)
          echo "Answer: $ANSWER"

          echo "$GH_PAT" | gh auth login --with-token
          gh issue comment "$ISSUE_NUMBER" --body "$ANSWER"
          gh issue edit "$ISSUE_NUMBER" --remove-label "chatcompletion"
